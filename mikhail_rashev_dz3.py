#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 21 00:15:59 2022

@author: rashev
"""

import random as rn

"""
Урок 3. Функции. Словари
1. Написать функцию num_translate(), 
переводящую числительные от 0 до 10 c английского на русский язык. Например:
>>> num_translate("one")
"один"
>>> num_translate("eight")
"восемь"

Если перевод сделать невозможно, вернуть None. 
Подумайте, как и где лучше хранить информацию, необходимую для перевода: 
какой тип данных выбрать, в теле функции или снаружи.
"""
def num_translate(num):
    switch = {
         "one": "один",
         "two": "два",
         "three": "три",
         "four": "четыре",
         "five": "пять",
         "six": "шесть",
         "seven": "семь",
         "eight": "восемь",
         "nine": "девять",
         "ten": "десять"        
    }
    if num in switch.keys():
        return switch.get(num)
    else:
        return None

print("ДЗ 1.")
print( num_translate("one") )

"""
2. * (вместо задачи 1) 
Доработать предыдущую функцию в num_translate_adv(): 
реализовать корректную работу с числительными, начинающимися с заглавной буквы
— результат тоже должен быть с заглавной. Например:

>>> num_translate_adv("One")
"Один"
>>> num_translate_adv("two")
"два"
"""

def num_translate_adv(num):
    capital = ["O", "T", "F", "S", "E", "N"]
    switch = {
         "one": "один",
         "two": "два",
         "three": "три",
         "four": "четыре",
         "five": "пять",
         "six": "шесть",
         "seven": "семь",
         "eight": "восемь",
         "nine": "девять",
         "ten": "десять"        
    }
    ret = ""
    if num[0] in capital:
        ret = switch.get(num.lower()).capitalize()  
    elif num in switch.keys():
        ret = switch.get(num)
    else:
        ret = "Error"
    
    return ret

print("ДЗ 2.")
print( num_translate_adv("one") )
print( num_translate_adv("One") )
print( num_translate_adv("two") )

"""
3. Написать функцию thesaurus(), принимающую в качестве аргументов 
имена сотрудников и возвращающую словарь, в котором ключи — первые буквы имён, 
а значения — списки, содержащие имена, начинающиеся с соответствующей буквы. 
Например:

>>>  thesaurus("Иван", "Мария", "Петр", "Илья")
{
    "И": ["Иван", "Илья"], 
    "М": ["Мария"], "П": ["Петр"]
}

Подумайте: полезен ли будет вам оператор распаковки? 
Как поступить, если потребуется сортировка по ключам? 
Можно ли использовать словарь в этом случае?
"""

def thesaurus(name1, *args):
    ret_letters = []
    ret_dict = {}
    synonims = {
        "И": ["Иван", "Илья", "Игорь"],
        "А": ["Александр", "Афанасий", "Алексей", "Анна", "Анастасия", "Алёна"],  
        "М": ["Марина", "Мария", "Мила", "Марья"],
        "В": ["Василий", "Виталий", "Виктор"],
        "П": ["Пётр", "Павел"]
    }
    ret_letters.append(name1[0].capitalize())
    if len(args) > 0:
        for elem in args:
            ret_letters.append(elem[0].capitalize())
    
    for letter in ret_letters:
        update_str = {letter: synonims.get(letter)}
        ret_dict.update(update_str)
    
    return ret_dict


print("\nДЗ 2.")
ret = thesaurus("Иван", "Мария", "Петр", "Илья")
print(ret)

"""
4. * (вместо задачи 3) Написать функцию thesaurus_adv(), 
принимающую в качестве аргументов строки в формате «Имя Фамилия» и 
возвращающую словарь, в котором ключи — первые буквы фамилий, 
а значения — словари, реализованные по схеме предыдущего задания и 
содержащие записи, в которых фамилия начинается с соответствующей буквы. 
Например:

>>> thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр Алексеев", 
"Илья Иванов", "Анна Савельева")
{
    "А": {
        "П": ["Петр Алексеев"]
    },
    "И": {
        "И": ["Илья Иванов"]
    },
    "С": {
        "И": ["Иван Сергеев", "Инна Серова"], 
        "А": ["Анна Савельева"]
    }
}



Как поступить, если потребуется сортировка по ключам?
"""

# Смоделировать  внешнюю библиотеку mylib, хранящую словари 
def mylib_get_synonims():
    synonims = {
        "И": ["Иван", "Илья", "Игорь"],
        "А": ["Александр", "Афанасий", "Алексей", "Анна", "Анастасия", "Алёна"],  
        "М": ["Марина", "Мария", "Мила", "Марья"],
        "В": ["Василий", "Виталий", "Виктор"],
        "П": ["Пётр", "Павел"]
    }
    return synonims

def thesaurus_adv(*args):
    if len(args) == 0: return 0
    ret_dict = {}
    dict_keys = []
    
    for val in args:
        first_name, last_name = val.strip().split()
        upd_arr = [last_name[0], first_name[0], val]
        dict_keys.append(upd_arr)
        ret_dict.update({last_name[0]:{}})
        
    for val in dict_keys:
        ret_dict[val[0]].update({val[1]:val[2]})
    
    return ret_dict

print("\nДЗ 4.")        
print( thesaurus_adv("Иван Сергеев", "Инна Серова", "Петр Алексеев", 
"Илья Иванов", "Анна Савельева") )

"""
5. Реализовать функцию get_jokes(), возвращающую n шуток, 
сформированных из трех случайных слов, взятых из трёх списков 
(по одному из каждого):

nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью"]
adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]

        Например:

>>> get_jokes(2)
["лес завтра зеленый", "город вчера веселый"]

Документировать код функции.
Сможете ли вы добавить еще один аргумент — флаг, 
разрешающий или запрещающий повторы слов в шутках 
(когда каждое слово можно использовать только в одной шутке)? 
Сможете ли вы сделать аргументы именованными?
"""

print("\nДЗ 5.")

def get_jokes(noun, adv, adj, num, allow=1):
    """
    Функция get_jokes создаёт набор шуток.
    принимает 3 списка: 
    существительное(noun), 
    показатель времени(adv), 
    прилагательное(adj)
    также принимает число шуток(num) и 
    флаг разрешающий повторное использование слов.
    Функция возвращает список шуток из 3 слов.
    Порядок слов: существительное, время, прилагательное 
    """
    list1 = nouns
    list2 = adv
    list3 = adj
    jokes = []
    for i in range(num):
        word1 = rn.choice(list1)
        word2 = rn.choice(list2)
        word3 = rn.choice(list3)
        phrase = word1 + " " + word2 + " " + word3
        jokes.append(phrase)
        if allow == 1:
            list1.remove(word1)
            list2.remove(word2)
            list3.remove(word3)
        else:
            pass
    
    return jokes
    

nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью"]
adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]

rand_joukes = get_jokes(nouns, adverbs, adjectives, 2)
print(rand_joukes)

